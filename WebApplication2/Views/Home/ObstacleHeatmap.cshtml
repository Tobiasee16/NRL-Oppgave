@{
    ViewData["Title"] = "Luftfartshindre – Heatmap";
    Layout = "_Layout";
}

<link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />

<div class="container mt-4">
    <!-- Tittel + knapp til Pilot Mode -->
    <div class="mb-2 d-flex align-items-center" id="heatmapHeader" style="gap: 1rem;">
    <div style="
        display:inline-flex;
        align-items:center;
        gap:0.5rem;
        padding:0.35rem 0.9rem;
        border-radius:9999px;
        background:rgba(59,130,246,0.14);
        border:1px solid rgba(59,130,246,0.55);
    ">
        <span style="font-weight:600; color:#bfdbfe;">Aviation obstacles</span>
        <span style="font-size:0.85rem; color:#9ca3af;">Heatmap</span>
    </div>

    <a asp-controller="Home"
       asp-action="PilotMode"
       class="btn btn-sm"
       style="
            padding:0.35rem 0.9rem;
            border-radius:9999px;
            border:1px solid #22c55e;
            background:rgba(21,128,61,0.15);
            color:#bbf7d0;
            font-size:0.8rem;
       ">
        Enter Pilot Mode
    </a>
</div>


    <!-- Beskrivelse -->
    <p style="max-width:60rem; font-size:0.9rem; color:#e5e7eb; margin-top:0.5rem;">
        The map displays a heatmap based on point data from the National Register of Aviation Obstacles.
        Your position (if you grant access) is shown as a marker, and the number of obstacles within a
        specified area around you is calculated continuously.
    </p>

    <!-- Kart + overlay -->
    <div class="mt-4" id="heatmapWrapper" style="position:relative;">

        <!-- 5 km-chip -->
        <div id="obstacleSummary"
             style="
                position:absolute;
                top:12px;
                right:12px;
                z-index:1000;
                background:rgba(15,23,42,0.96);
                color:#e5e7eb;
                font-size:0.8rem;
                padding:4px 10px;
                border-radius:9999px;
                border:1px solid #334155;
                white-space:nowrap;
             ">
            Loading obstacle data…
        </div>

        <div id="heatmap"
             style="height:70vh; width:100%; border-radius:8px; border:1px solid #334155; overflow:hidden;">
        </div>
    </div>
</div>

@section Scripts {
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet.heat/dist/leaflet-heat.js"></script>

    <script>
        // --- Kartoppsett (normalvisning) ---

        const map = L.map('heatmap', {
            zoomControl: true,
            worldCopyJump: false,
            maxBoundsViscosity: 1.0,
            maxBounds: [
                [-85, -180],
                [85, 180]
            ]
        }).setView([58.2, 8.0], 12); // omtrent Kristiansand

        const osmLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            minZoom: 4,
            maxZoom: 19,
            noWrap: true,
            attribution: '&copy; OpenStreetMap contributors'
        }).addTo(map);

        let heatLayer = null;
        const dataUrl = '@Url.Action("NrlPunktData", "Home")';

        let obstacleFeatures = [];
        let lastUserLatLng = null;
        let hasObstacleData = false;

        // --- Hjelpefunksjoner ---

        function distanceKm(lat1, lon1, lat2, lon2) {
            const R = 6371;
            const toRad = deg => deg * Math.PI / 180;

            const dLat = toRad(lat2 - lat1);
            const dLon = toRad(lon2 - lon1);
            const a =
                Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
                Math.sin(dLon / 2) * Math.sin(dLon / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            return R * c;
        }

        function setSummary(text) {
            const box = document.getElementById('obstacleSummary');
            if (!box) return;
            box.textContent = text;
        }

        function recomputeSummary() {
            if (!hasObstacleData && !lastUserLatLng) {
                setSummary("Loading position and obstacles…");
                return;
            }

            if (!hasObstacleData) {
                setSummary("Loading obstacle data…");
                return;
            }

            if (!lastUserLatLng) {
                setSummary("Waiting for position…");
                return;
            }

            const radiusKm = 5;
            let count = 0;

            for (const f of obstacleFeatures) {
                if (!f.geometry || !f.geometry.coordinates || f.geometry.coordinates.length < 2)
                    continue;

                const lon = f.geometry.coordinates[0];
                const lat = f.geometry.coordinates[1];
                const d = distanceKm(lastUserLatLng.lat, lastUserLatLng.lng, lat, lon);
                if (d <= radiusKm) count++;
            }

            setSummary(`Obstacles within ${radiusKm} km: ${count}`);
        }

        // --- Hent hinderdata + heatmap ---

        fetch(dataUrl)
            .then(r => {
                if (!r.ok) {
                    console.error('HTTP error loading obstacle data:', r.status, r.statusText);
                    throw new Error('HTTP ' + r.status);
                }
                return r.json();
            })
            .then(data => {
                obstacleFeatures = data.features || [];
                hasObstacleData = true;

                const heatPoints = obstacleFeatures
                    .map(f => {
                        if (!f.geometry || !f.geometry.coordinates || f.geometry.coordinates.length < 2)
                            return null;

                        const lon = f.geometry.coordinates[0];
                        const lat = f.geometry.coordinates[1];
                        const props = f.properties || {};
                        const h = props.vertikalAvstand || 0;
                        const weight = Math.min(1, (h || 50) / 300.0);

                        return [lat, lon, weight];
                    })
                    .filter(p => p !== null);

                heatLayer = L.heatLayer(heatPoints, {
                    radius: 25,
                    blur: 15,
                    maxZoom: 12
                }).addTo(map);

                recomputeSummary();
            })
            .catch(err => {
                console.error('Error loading GeoJSON:', err);
                setSummary("Could not load obstacle data.");
                alert('Could not load obstacle data.');
            });

        // --- GPS-dot (iOS/Android-stil) ---

        const userIcon = L.divIcon({
            html: `
                <div style="
                    width:18px;
                    height:18px;
                    background:#007AFF;
                    border-radius:50%;
                    border:2px solid white;
                    box-shadow:0 0 0 5px rgba(0,122,255,0.35);
                "></div>
            `,
            className: "",
            iconSize: [18, 18],
            iconAnchor: [9, 9]
        });

        let userMarker = null;
        let accuracyCircle = null;
        let hasCenteredOnUser = false;
        let moveAnimationFrame = null;

        function animateMarkerMove(fromLatLng, toLatLng, durationMs) {
            if (!userMarker) return;
            if (!fromLatLng) {
                userMarker.setLatLng(toLatLng);
                return;
            }

            if (moveAnimationFrame !== null) {
                cancelAnimationFrame(moveAnimationFrame);
                moveAnimationFrame = null;
            }

            const start = performance.now();

            function step(timestamp) {
                const elapsed = timestamp - start;
                const t = Math.min(1, elapsed / durationMs);

                const lat = fromLatLng.lat + (toLatLng.lat - fromLatLng.lat) * t;
                const lng = fromLatLng.lng + (toLatLng.lng - fromLatLng.lng) * t;
                userMarker.setLatLng([lat, lng]);

                if (t < 1) {
                    moveAnimationFrame = requestAnimationFrame(step);
                } else {
                    moveAnimationFrame = null;
                }
            }

            moveAnimationFrame = requestAnimationFrame(step);
        }

        if ("geolocation" in navigator) {
            navigator.geolocation.watchPosition(
                function (pos) {
                    const lat = pos.coords.latitude;
                    const lon = pos.coords.longitude;
                    const acc = pos.coords.accuracy;

                    const newLatLng = L.latLng(lat, lon);
                    const prevLatLng = lastUserLatLng;
                    lastUserLatLng = newLatLng;

                    if (!userMarker) {
                        userMarker = L.marker(newLatLng, {
                            icon: userIcon,
                            title: "Your position"
                        }).addTo(map);

                        accuracyCircle = L.circle(newLatLng, {
                            radius: acc
                        }).addTo(map);
                    } else {
                        animateMarkerMove(prevLatLng, newLatLng, 500);
                        accuracyCircle.setLatLng(newLatLng);
                        accuracyCircle.setRadius(acc);
                    }

                    if (!hasCenteredOnUser) {
                        map.setView(newLatLng, 10);
                        hasCenteredOnUser = true;
                    }

                    recomputeSummary();
                },
                function (err) {
                    console.warn("Geolocation error:", err);
                    setSummary("Could not get position (" + err.message + ").");
                },
                {
                    enableHighAccuracy: true,
                    timeout: 10000,
                    maximumAge: 5000
                }
            );
        } else {
            console.warn("Geolocation not supported.");
            setSummary("Geolocation is not supported in this browser.");
        }
    </script>
}
